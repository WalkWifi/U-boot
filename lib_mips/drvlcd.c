#include "drvlcd.h"
#include <common.h>
#include <serial.h>
//V1.0	//2016.03.21
#define LCD_VERSION "2.0"	//2015.09.16

#define BOARD_TYPE_V1_0     0   //3+4g
#define BOARD_TYPE_V2_0     1   //2+4G,LCD
#define BOARD_TYPE_V2_1     2   //2+4G,NO LCD

#define VIFI_BOARD_TYPE BOARD_TYPE_V2_1

#if VIFI_BOARD_TYPE == BOARD_TYPE_V1_0  
#define UBOOT_INFO \
"==>Board:BOARD_TYPE_V1_0\n\
  +Author:Kevin Wei @20160719\n\
  +console=uart2,power_en,led_en,\n\
  +lowPower,Charge/PowerOff,lcd display.\n\
  +softreset/powerkey boot.\n"

#elif VIFI_BOARD_TYPE == BOARD_TYPE_V2_0
#define UBOOT_INFO \
"==>Board:BOARD_TYPE_V2_0\n\
  +Author:Kevin Wei @20160719\n\
  +console=uart2,power_en,led_en,\n\
  +lowPower,Charge/PowerOff,lcd display.\n\
  +softreset/powerkey boot.\n"

#elif VIFI_BOARD_TYPE == BOARD_TYPE_V2_1
#define UBOOT_INFO \
"==>Board:BOARD_TYPE_V2_1\n\
  +Author:Kevin Wei @20161021\n\
  +console=uart2,power_en,led_en,\n\
  +softreset/powerkey boot,short press.\n"

#else

#endif



#define EOS_OK  0
#define EOS_ERROR 1

#define SYS_RSTCTL_ADDR 0xB0000038  //reset system and device.
#define GPIO1_MODE_ADDR 0xB0000060
#define GPIO2_MODE_ADDR 0xB0000064
#define GPIO0_CTRL_ADD 0XB0000600
#define GPIO1_CTRL_ADD 0XB0000604
#define GPIO0_DATA_ADD 0XB0000620	//read or write data
#define GPIO1_DATA_ADD 0XB0000624

//LCD infomation
#define SLAVE_ADDR    0x7A	//A0=1,add=0x7A;A0=0,add=0x78;
#define LCD_COLUMN_MAX 128
#define LCD_LINE_MAX 8
#define TYPE_DATA  0X40
#define TYPE_CMD   0

#define GPIO_SDA_PIN	5
#define GPIO_SCL_PIN	4
#define GPIO_RST_PIN	6

#define IIC_RST_OUT() (*(unsigned int *)GPIO0_CTRL_ADD |= (1 << GPIO_RST_PIN))
#define IIC_SDA_OUT() (*(unsigned int *)GPIO0_CTRL_ADD |= (1 << GPIO_SDA_PIN))
#define IIC_SDA_IN()  (*(unsigned int *)GPIO0_CTRL_ADD &= ~(1 << GPIO_SDA_PIN))
#define IIC_SCL_OUT() (*(unsigned int *)GPIO0_CTRL_ADD |= (1 << GPIO_SCL_PIN))

#define IIC_RST_SET() (*(unsigned int *)GPIO0_DATA_ADD |= (1 << GPIO_RST_PIN))
#define IIC_RST_CLR() (*(unsigned int *)GPIO0_DATA_ADD &= ~(1 << GPIO_RST_PIN))
#define IIC_SDA_SET() (*(unsigned int *)GPIO0_DATA_ADD |= (1 << GPIO_SDA_PIN))
#define IIC_SDA_CLR() (*(unsigned int *)GPIO0_DATA_ADD &= ~(1 << GPIO_SDA_PIN))
#define IIC_SCL_SET() (*(unsigned int *)GPIO0_DATA_ADD |= (1 << GPIO_SCL_PIN))
#define IIC_SCL_CLR() (*(unsigned int *)GPIO0_DATA_ADD &= ~(1 << GPIO_SCL_PIN))
#define IIC_SDA_GET() (((*(unsigned int *)GPIO0_DATA_ADD) >> GPIO_SDA_PIN) & 1)	//get the value of SDA pin

//GPIO config
#define GPIO_PWREN_PIN  11  //enable the battery connect pin.
#define GPIO_VOLDET_PIN 3   //detect the low power pin.
#define GPIO_ACIN_PIN   25  //detect the AC adapter in,in=0, out=1.(AC_IN)
#define GPIO_CHARGE_EN  37  //enable the fast charge pin
#define GPIO_PWRKEY_PIN 24  //detect the power button pin.

//H330 GPIO
#define GPIO_G3_WAKEUP   1
#define GPIO_G3_RESET    17
#define GPIO_G3_POWERON  16
#define GPIO_G3_POWEROFF 14


#define GPIO_VOLDET_GET() (((*(unsigned int *)GPIO0_DATA_ADD) >> GPIO_VOLDET_PIN) & 1)
#define GPIO_PWRKEY_GET() (((*(unsigned int *)GPIO0_DATA_ADD) >> GPIO_PWRKEY_PIN) & 1)
#define GPIO_ACIN_GET()   (((*(unsigned int *)GPIO0_DATA_ADD) >> GPIO_ACIN_PIN) & 1)



const unsigned char font_8X16[95][16]=
{	  
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x09,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
{0x00,0x00,0x00,0x00,0xF0,0x00,0x30,0x00,0x00,0x00,0xF0,0x00,0x30,0x00,0x00,0x00},/*""",2*/
{0x00,0x00,0x40,0x1A,0xE0,0x07,0x58,0x02,0x40,0x1A,0xE0,0x07,0x58,0x02,0x00,0x00},/*"#",3*/
{0x00,0x00,0x00,0x00,0x60,0x06,0x90,0x04,0x98,0x1C,0x30,0x03,0x00,0x00,0x00,0x00},/*"$",4*/
{0x00,0x00,0x20,0x01,0x50,0x01,0x20,0x05,0x80,0x0A,0x80,0x04,0x00,0x00,0x00,0x00},/*"%",5*/
{0x00,0x00,0x00,0x00,0x00,0x06,0xC0,0x09,0x20,0x0B,0x20,0x0C,0x20,0x0A,0x00,0x00},/*"&",6*/
{0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x0F,0x30,0x30,0x00,0x00,0x00,0x00},/*"(",8*/
{0x00,0x00,0x00,0x00,0x30,0x30,0xC0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*")",9*/
{0x00,0x00,0x00,0x00,0x20,0x00,0xA0,0x01,0x70,0x00,0xA0,0x01,0x20,0x00,0x00,0x00},/*"*",10*/
{0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0xE0,0x0F,0x00,0x01,0x00,0x01,0x00,0x01},/*"+",11*/
{0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x1C,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
{0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00},/*"-",13*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
{0x00,0x00,0x00,0x18,0x00,0x06,0x80,0x01,0x60,0x00,0x18,0x00,0x00,0x00,0x00,0x00},/*"/",15*/
{0x00,0x00,0xE0,0x07,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0xE0,0x07,0x00,0x00},/*"0",16*/
{0x00,0x00,0x00,0x00,0x20,0x08,0x20,0x08,0xF0,0x0F,0x00,0x08,0x00,0x08,0x00,0x00},/*"1",17*/
{0x00,0x00,0x20,0x0C,0x10,0x0A,0x10,0x09,0x90,0x08,0x60,0x0C,0x00,0x00,0x00,0x00},/*"2",18*/
{0x00,0x00,0x20,0x04,0x10,0x08,0x90,0x08,0x90,0x08,0x60,0x07,0x00,0x00,0x00,0x00},/*"3",19*/
{0x00,0x00,0x00,0x01,0xC0,0x01,0x20,0x01,0x10,0x09,0xF0,0x0F,0x00,0x09,0x00,0x00},/*"4",20*/
{0x00,0x00,0x00,0x04,0xF0,0x08,0x90,0x08,0x90,0x08,0x90,0x08,0x10,0x07,0x00,0x00},/*"5",21*/
{0x00,0x00,0x00,0x00,0xC0,0x07,0xA0,0x08,0x90,0x08,0x90,0x08,0x10,0x07,0x00,0x00},/*"6",22*/
{0x00,0x00,0x30,0x00,0x10,0x00,0x10,0x00,0x10,0x0E,0x90,0x01,0x70,0x00,0x00,0x00},/*"7",23*/
{0x00,0x00,0x60,0x07,0x90,0x08,0x90,0x08,0x90,0x08,0x90,0x08,0x60,0x07,0x00,0x00},/*"8",24*/
{0x00,0x00,0xE0,0x08,0x10,0x09,0x10,0x09,0x10,0x09,0x10,0x05,0xE0,0x03,0x00,0x00},/*"9",25*/
{0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x0C,0xC0,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x00,0x00,0x18,0xC0,0x0C,0xC0,0x04,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
{0x00,0x00,0x00,0x01,0x00,0x01,0x80,0x02,0x40,0x04,0x40,0x04,0x20,0x08,0x00,0x00},/*"<",28*/
{0x00,0x00,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x00,0x00},/*"=",29*/
{0x00,0x00,0x20,0x08,0x40,0x04,0x40,0x04,0x80,0x02,0x00,0x01,0x00,0x01,0x00,0x00},/*">",30*/
{0x00,0x00,0x00,0x00,0x20,0x00,0x10,0x08,0x10,0x0A,0x10,0x01,0xE0,0x00,0x00,0x00},/*"?",31*/
{0x00,0x00,0xF0,0x0F,0x08,0x10,0x88,0x11,0x48,0x12,0xF0,0x0B,0x00,0x00,0x00,0x00},/*"@",32*/
{0x00,0x00,0x00,0x08,0x00,0x0C,0xD0,0x0B,0x30,0x02,0xC0,0x0B,0x00,0x0C,0x00,0x08},/*"A",33*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x90,0x08,0x90,0x08,0x90,0x08,0x60,0x07,0x00,0x00},/*"B",34*/
{0x00,0x00,0xC0,0x03,0x20,0x04,0x10,0x08,0x10,0x08,0x10,0x08,0x30,0x04,0x00,0x00},/*"C",35*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x10,0x08,0x10,0x08,0x20,0x04,0xC0,0x03,0x00,0x00},/*"D",36*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x90,0x08,0xD0,0x09,0x10,0x08,0x30,0x0C,0x00,0x00},/*"E",37*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x90,0x08,0xD0,0x01,0x10,0x00,0x30,0x00,0x00,0x00},/*"F",38*/
{0x00,0x00,0xC0,0x03,0x20,0x04,0x10,0x08,0x10,0x08,0x10,0x09,0x30,0x07,0x00,0x01},/*"G",39*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x90,0x08,0x80,0x00,0x90,0x08,0xF0,0x0F,0x10,0x08},/*"H",40*/
{0x00,0x00,0x00,0x00,0x10,0x08,0x10,0x08,0xF0,0x0F,0x10,0x08,0x10,0x08,0x00,0x00},/*"I",41*/
{0x00,0x00,0x00,0x07,0x00,0x08,0x10,0x08,0x10,0x08,0xF0,0x07,0x10,0x00,0x00,0x00},/*"J",42*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x10,0x09,0x80,0x01,0x50,0x02,0x30,0x0C,0x10,0x08},/*"K",43*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x10,0x08,0x00,0x08,0x00,0x08,0x00,0x0E,0x00,0x00},/*"L",44*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x70,0x08,0x80,0x01,0x70,0x08,0xF0,0x0F,0x10,0x08},/*"M",45*/
{0x10,0x08,0xF0,0x0F,0x30,0x08,0xC0,0x00,0x00,0x03,0x10,0x0C,0xF0,0x0F,0x10,0x00},/*"N",46*/
{0x00,0x00,0xC0,0x03,0x20,0x04,0x10,0x08,0x10,0x08,0x10,0x08,0x20,0x04,0xC0,0x03},/*"O",47*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x10,0x09,0x10,0x01,0x10,0x01,0xE0,0x00,0x00,0x00},/*"P",48*/
{0x00,0x00,0xC0,0x03,0x20,0x04,0x10,0x18,0x10,0x18,0x10,0x18,0x20,0x14,0xC0,0x13},/*"Q",49*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x10,0x09,0x10,0x01,0x10,0x03,0xE0,0x04,0x00,0x08},/*"R",50*/
{0x00,0x00,0x60,0x0C,0x90,0x04,0x90,0x08,0x90,0x08,0xA0,0x08,0x30,0x07,0x00,0x00},/*"S",51*/
{0x00,0x00,0x30,0x00,0x10,0x00,0x10,0x08,0xF0,0x0F,0x10,0x08,0x10,0x00,0x30,0x00},/*"T",52*/
{0x00,0x00,0x10,0x00,0xF0,0x07,0x10,0x08,0x00,0x08,0x10,0x08,0xF0,0x07,0x10,0x00},/*"U",53*/
{0x10,0x00,0x70,0x00,0x90,0x03,0x00,0x0C,0x00,0x0C,0x90,0x03,0x70,0x00,0x10,0x00},/*"V",54*/
{0x00,0x00,0x10,0x00,0xF0,0x07,0x10,0x08,0x80,0x07,0x10,0x08,0xF0,0x07,0x10,0x00},/*"W",55*/
{0x00,0x00,0x10,0x08,0x30,0x0C,0x50,0x0A,0x80,0x01,0x50,0x0A,0x30,0x0C,0x10,0x08},/*"X",56*/
{0x00,0x00,0x10,0x00,0x30,0x00,0xD0,0x08,0x00,0x0F,0xD0,0x08,0x30,0x00,0x10,0x00},/*"Y",57*/
{0x00,0x00,0x00,0x00,0x30,0x0C,0x10,0x0A,0x90,0x09,0x50,0x08,0x30,0x0C,0x00,0x00},/*"Z",58*/
{0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x3F,0x10,0x20,0x10,0x20,0x00,0x00,0x00,0x00},/*"[",59*/
{0x00,0x00,0x18,0x00,0x60,0x00,0x80,0x03,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00},/*"\",60*/
{0x00,0x00,0x10,0x20,0x10,0x20,0xF0,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"]",61*/
{0x00,0x00,0x40,0x00,0x20,0x00,0x18,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
{0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},/*"_",63*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
{0x00,0x00,0x80,0x06,0x40,0x09,0x40,0x09,0x40,0x09,0x40,0x05,0x80,0x0F,0x00,0x08},/*"a",65*/
{0x10,0x08,0xF0,0x0F,0x80,0x04,0x40,0x08,0x40,0x08,0x40,0x08,0x80,0x07,0x00,0x00},/*"b",66*/
{0x00,0x00,0x80,0x07,0x40,0x08,0x40,0x08,0x40,0x08,0x80,0x08,0xC0,0x04,0x00,0x00},/*"c",67*/
{0x00,0x00,0x80,0x07,0x40,0x08,0x40,0x08,0x40,0x08,0x90,0x04,0xF0,0x0F,0x00,0x08},/*"d",68*/
{0x00,0x00,0x80,0x07,0x40,0x09,0x40,0x09,0x40,0x09,0x40,0x09,0x80,0x09,0x00,0x00},/*"e",69*/
{0x00,0x00,0x40,0x08,0x40,0x08,0xE0,0x0F,0x50,0x08,0x50,0x08,0x50,0x08,0x00,0x00},/*"f",70*/
{0x00,0x00,0x80,0x07,0x40,0x28,0x40,0x28,0x40,0x28,0x80,0x24,0xC0,0x1F,0x40,0x00},/*"g",71*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x80,0x08,0x40,0x00,0x40,0x08,0x80,0x0F,0x00,0x08},/*"h",72*/
{0x00,0x00,0x00,0x00,0x40,0x08,0x40,0x08,0xD0,0x0F,0x00,0x08,0x00,0x08,0x00,0x00},/*"i",73*/
{0x00,0x00,0x00,0x20,0x40,0x20,0x40,0x20,0x50,0x20,0xC0,0x1F,0x00,0x00,0x00,0x00},/*"j",74*/
{0x00,0x00,0x10,0x08,0xF0,0x0F,0x00,0x01,0x40,0x03,0xC0,0x0C,0x40,0x08,0x40,0x08},/*"k",75*/
{0x00,0x00,0x00,0x00,0x00,0x08,0x10,0x08,0xF0,0x0F,0x00,0x08,0x00,0x08,0x00,0x00},/*"l",76*/
{0x40,0x08,0xC0,0x0F,0x80,0x08,0x40,0x00,0x80,0x0F,0x80,0x08,0x40,0x00,0x80,0x0F},/*"m",77*/
{0x00,0x00,0x40,0x08,0xC0,0x0F,0x80,0x08,0x40,0x00,0x40,0x08,0x80,0x0F,0x00,0x08},/*"n",78*/
{0x00,0x00,0x80,0x07,0x40,0x08,0x40,0x08,0x40,0x08,0x40,0x08,0x80,0x07,0x00,0x00},/*"o",79*/
{0x00,0x00,0x40,0x20,0xC0,0x3F,0x80,0x28,0x40,0x08,0x40,0x08,0x80,0x07,0x00,0x00},/*"p",80*/
{0x00,0x00,0x80,0x07,0x40,0x08,0x40,0x08,0x40,0x08,0x80,0x24,0xC0,0x3F,0x40,0x20},/*"q",81*/
{0x00,0x00,0x40,0x08,0xC0,0x0F,0x80,0x08,0x40,0x08,0x40,0x08,0x40,0x00,0x00,0x00},/*"r",82*/
{0x00,0x00,0x80,0x0C,0x40,0x09,0x40,0x09,0x40,0x09,0x40,0x09,0xC0,0x06,0x00,0x00},/*"s",83*/
{0x00,0x00,0x40,0x00,0xE0,0x07,0x40,0x08,0x40,0x08,0x40,0x08,0x00,0x04,0x00,0x00},/*"t",84*/
{0x00,0x00,0x40,0x00,0xC0,0x07,0x00,0x08,0x00,0x08,0x40,0x04,0xC0,0x0F,0x00,0x08},/*"u",85*/
{0x40,0x00,0xC0,0x00,0x40,0x03,0x00,0x0C,0x00,0x0C,0x40,0x03,0xC0,0x00,0x40,0x00},/*"v",86*/
{0x00,0x00,0x40,0x00,0xC0,0x07,0x40,0x08,0x00,0x07,0x40,0x08,0xC0,0x07,0x40,0x00},/*"w",87*/
{0x00,0x00,0x40,0x08,0xC0,0x0C,0x00,0x03,0x00,0x03,0xC0,0x0C,0x40,0x08,0x00,0x00},/*"x",88*/
{0x00,0x00,0x40,0x00,0xC0,0x21,0x40,0x26,0x00,0x38,0x40,0x06,0xC0,0x01,0x40,0x00},/*"y",89*/
{0x00,0x00,0x00,0x00,0xC0,0x0C,0x40,0x0A,0x40,0x09,0xC0,0x08,0x40,0x0C,0x00,0x00},/*"z",90*/
{0x00,0x00,0x00,0x00,0x00,0x01,0xE0,0x0E,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00},/*"{",91*/
{0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"|",92*/
{0x00,0x00,0x00,0x00,0x10,0x10,0xE0,0x0E,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
{0x00,0x00,0x00,0x01,0x80,0x00,0x80,0x00,0x00,0x01,0x00,0x01,0x80,0x00,0x00,0x00},/*"~",94*/
}; 

const char batIco[48] = {
 0x00,0x00,0x00,0x00,0xC0,0x03,0xC0,0x03,0xF0,0x0F,0x10,0x08,0x10,0x08,0x10,0x08,
 0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,
 0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0xF0,0x0F,0x00,0x00};

typedef struct {
	unsigned char dataType;	//
	unsigned char cmd;			//
	unsigned char dataBuff[1024];	//data buffer

}ST_LCD_PARAM;


static ST_LCD_PARAM lcdParam;

static void lcdGpioInit(void)
{
	unsigned int registerVal = 0;

	//spi_cs1_mode,bit4:5=01 ,i2c_mode,bit20:21=01
	registerVal = *(unsigned int *)GPIO1_MODE_ADDR;
	registerVal = registerVal & (~(3<<4)) & (~(3<<20));
	registerVal = registerVal | (1<<4) | (1<<20);
	*(unsigned int *)GPIO1_MODE_ADDR = registerVal;
	IIC_RST_OUT();
	IIC_SDA_OUT();
	IIC_SCL_OUT();
	IIC_SDA_SET();
	IIC_SCL_CLR();
}
static void iicStart(void)
{
    // SDA 1->0 while SCL High
    IIC_SDA_SET();   
    IIC_SCL_SET();
    udelay(1);              
    IIC_SDA_CLR();
    udelay(1);                 
    IIC_SCL_CLR();
    udelay(1);
}

static void iicStop(void)
{
	IIC_SCL_CLR(); 
    IIC_SDA_CLR(); 
    IIC_SCL_SET();                
    udelay(1);
    IIC_SDA_SET();
    udelay(1);
    IIC_SCL_CLR();
    udelay(1);
}
#define NOACK 1  //high = noack
#define ACK   0  //low  = ack
static unsigned char iicWaitAck(void)
{
    unsigned char recvAck;
    
    IIC_SCL_CLR(); 
    IIC_SDA_CLR();
    IIC_SDA_IN();
	udelay(1);
    IIC_SCL_SET();
    udelay(1);
    recvAck = (unsigned char)IIC_SDA_GET();  
    udelay(1);
    IIC_SCL_CLR();                    
    IIC_SDA_OUT();
    IIC_SDA_SET();
    udelay(1);
    return recvAck;
}

static unsigned char iicSendByte(unsigned char data)
{
    unsigned char recvAck, i;
	IIC_SCL_CLR();
    for (i= 0 ; i< 8; i++){               
 		if (data & (0x80 >> i)){  // write data ,MSB first
       		IIC_SDA_SET();
 		}else {
       		IIC_SDA_CLR();
 		}
		udelay(1);
        IIC_SCL_SET();
        udelay(2);
        IIC_SCL_CLR();
        udelay(1);
    }
    recvAck = iicWaitAck();

    return recvAck;
}

//返回EOS_OK=成功，EOS_ERROR=失败
static int iicWriteOneByte(unsigned char mode,unsigned char data)
{
    unsigned char recvAck;
    iicStart();
    recvAck = iicSendByte(SLAVE_ADDR);	//send slave address and w/r w=0,r=1
    if(recvAck == NOACK)
        return EOS_ERROR;
    recvAck = iicSendByte(mode);
    if(recvAck == NOACK)
        return EOS_ERROR;
    recvAck = iicSendByte(data);
    if(recvAck == NOACK)
        return EOS_ERROR;
    iicStop();
    return EOS_OK;
}

static void iicWriteCmd(unsigned char cmd)
{
	iicWriteOneByte(TYPE_CMD,cmd);
}

static void iicWriteData(unsigned char data)
{
	iicWriteOneByte(TYPE_DATA,data);
}

/*
 * 填充LCD整屏数据
 */
#define LCD_MAX_POSX 128
#define LCD_MAX_POSY 64
#define ADD_OFFSET    2
static int lcdFillDataFull(unsigned char * fill_data)
{
    unsigned char m, n;
    for (m = 0; m < (LCD_MAX_POSY/8); m++){
		iicWriteCmd(0x00 + ADD_OFFSET);		 //low column start address
		iicWriteCmd(0x10);					//high column start address
        iicWriteCmd(0xb0 + m);      //page0-page7
        iicStart();
        iicSendByte(SLAVE_ADDR);
        iicSendByte(TYPE_DATA); 
        for (n = 0; n < LCD_MAX_POSX; n++)
        {
            iicSendByte(*(fill_data++));
        }
        iicStop();
    }
	return EOS_OK;
}

static int lcdInit(void)
{
	IIC_RST_CLR();
	udelay(20);
	IIC_RST_SET();
	udelay(5);
	iicWriteCmd(0xAE); //Set Display Off
	iicWriteCmd(0xd5); //display divide ratio/osc. freq. mode
	iicWriteCmd(0x80); //
	iicWriteCmd(0xA8); //multiplex ration mode:63
	iicWriteCmd(0x3F);
	iicWriteCmd(0xD3); //Set Display Offset
	iicWriteCmd(0x00);
	iicWriteCmd(0x40); //Set Display Start Line
	iicWriteCmd(0xAD); //DC-DC Control Mode Set
	iicWriteCmd(0x8B); //8A:External 8b:Built-in DC-DC is used
	iicWriteCmd(0x32); //Set Pump voltage value
	iicWriteCmd(0xA1); //Segment Remap
	iicWriteCmd(0xC8); //Sst COM Output Scan Direction
	iicWriteCmd(0xDA); //common pads hardware: alternative
	iicWriteCmd(0x12);
	iicWriteCmd(0x81); //contrast control
	iicWriteCmd(0x40);
	iicWriteCmd(0xD9); //set pre-charge period
	iicWriteCmd(0x1f);
	iicWriteCmd(0xDB); //VCOM deselect level mode
	iicWriteCmd(0x40);
	iicWriteCmd(0xA4); //Set Entire Display On/Off
	iicWriteCmd(0xA6); //Set Normal Display
	iicWriteCmd(0xAF); //Set Display On

	return EOS_OK;
}

static int lcdPowerOff(void)
{
    IIC_RST_CLR();
    return EOS_OK;
}

/*
 *line:0-7;column:0-127;size:8*16/16*32.
 *pLcdParamData:lcd display buffer.
 *string: the string to display.
 */
int lcdDispString(u32 column, u32 line, ST_LCD_PARAM *pLcdParamData, const uint8_t *string)
{
    unsigned char charLibNum = 0,curLine = 0, curColumn = 0;
    unsigned char i;

    if((line > (LCD_LINE_MAX-2)) || (column > (LCD_COLUMN_MAX-8))){
            printf("LCD:(lcdDispString) | FONT8X16->The paramer is out of range.ERROR\n");
            return EOS_ERROR;
    }
    curLine = line;
    curColumn = column;
    while(*string != '\0'){
            charLibNum = *string - ' ';
            for(i = 0; i < 8; i++){
                    pLcdParamData->dataBuff[128 * curLine + curColumn + i] = font_8X16[charLibNum][i*2];
                    pLcdParamData->dataBuff[128 *(curLine + 1) + curColumn + i] = font_8X16[charLibNum][i*2+1];
            }
            curColumn += 8;
            string++;
            if(curColumn >= LCD_COLUMN_MAX){
                break;
            }
    }
    return EOS_OK;
}

unsigned int isSoftRst = 0;

unsigned int batStatusDet = 0;  //0->none,1->low power,2->ok
unsigned int batStatusKeep = 0;

unsigned int adapterDet = 0;  //0->no Adapter,1->adapter in.
unsigned int adapterDetKeep = 0;

unsigned int pwrKeyStatus = 0;  //0=no press, 1=keep pressing,2=press timeout
unsigned int pwrKeyKeep = 0;
unsigned int pwrKeyDetCnt = 20;


int Serial0_RecvHdl (void)
{
    static u8 serial0Rx[128] = {0,};
    static u8 serial0RxPtr = 0;
    u8 serial0RxOk = 0;
    u8 c = 0;
    u16 tmpVol = 0;
    ulong waitAckStartTick = 0;
    ulong waitAckTmo = 10000000 * (575 / 2); //timeout = 10s

    waitAckStartTick = get_timer(0);    //us
    //printf("current timer: %u\n", waitAckStartTick);
    
    while(1)
    {
        c = Serial0_Read();
        if(c == 0)
        {
            if((get_timer(0) - waitAckStartTick) > waitAckTmo) 
            {
                //printf("end timer: %u\n", get_timer(0));
                return -1;
            }
            continue;
        }
        if((c != '\r') && (c != '\n'))
        {
            serial0Rx[serial0RxPtr] = c;
            serial0RxPtr++;
            if(serial0RxPtr >= 128)
                serial0RxPtr = 0;
        }
        else
        {
            if(serial0RxPtr != 0)
            {
                serial0Rx[serial0RxPtr] = 0;
                serial0RxOk = 1;
                printf("read-: %s \n", serial0Rx);
            }
        }
        if(serial0RxOk == 1)
        {
            if(strncmp("AT command ready", serial0Rx, strlen("AT command ready")) == 0)
            {
                ;
            }
            else if(strncmp("OK", serial0Rx, strlen("OK")) == 0)
            {
                ;
            }
            else if((strncmp("+CBC: ", serial0Rx, strlen("+CBC: ")) == 0) && (serial0RxPtr > strlen("+CBC: 0,")))
            {
                serial0RxPtr = strlen("+CBC: 0,");
                while((serial0Rx[serial0RxPtr] != 0) && (serial0Rx[serial0RxPtr] != ' '))
                {
                    tmpVol *= 10;
                    tmpVol += (serial0Rx[serial0RxPtr++] - '0');
                }
                printf("Battery voltage = %d mV\n", tmpVol);
                if((tmpVol > 3500) && (tmpVol < 4500))
                {
                    batStatusDet = 2;
                }
                else
                {
                    batStatusDet = 1;
                }
            }
            
            serial0RxOk = 0;
            serial0RxPtr = 0;
            break;
        }
    }
    return 0;
}



    
int lcd_main(void)
{
    unsigned int tmpReg;
    unsigned char strBuff[17] = {};
    unsigned int  dispDelay = 0;
    unsigned int statusDetWait = 0;
    unsigned int batReadLoopCnt = 0;
    

    //power key.
    tmpReg = *((volatile u32 *)(GPIO1_MODE_ADDR));   //SW3,power pin ,SD_MODE=01,MDI_RP_P3=GPIO24
    *((volatile u32 *)(GPIO1_MODE_ADDR)) = (tmpReg & (~(3 << 10))) | (1 << 10);   
    *((volatile u32 *)(GPIO0_CTRL_ADD)) &= ~(1 << 24);     //dir=in
    //low power detect pin
    tmpReg = *((volatile u32 *)(GPIO1_MODE_ADDR));   //I2S_CLK,<VOLDET> is GPIO#3,I2S_MODE=01
    *((volatile u32 *)(GPIO1_MODE_ADDR)) = (tmpReg & (~(3 << 6))) | (1 << 6);   
    *((volatile u32 *)(GPIO0_CTRL_ADD)) &= ~(1 << 3);     //dir=in
    //fast charge pin.
    tmpReg = *((volatile u32 *)(GPIO1_MODE_ADDR));   ////REF_CLKO GPIO_MODE=1
    *((volatile u32 *)(GPIO1_MODE_ADDR)) = tmpReg | (1 << 18);
    *((volatile u32 *)(GPIO1_CTRL_ADD)) |= (1 << (GPIO_CHARGE_EN-32));
    *((volatile u32 *)(GPIO1_DATA_ADD)) |= (1 << (GPIO_CHARGE_EN-32));
    //AC adapter pin.
    tmpReg = *((volatile u32 *)(GPIO1_MODE_ADDR));  //SD_MODE=01.#GPIO25
    *((volatile u32 *)(GPIO1_MODE_ADDR)) = (tmpReg & (~(0x3<<10))) | (0x1<<10);
    *((volatile u32 *)(GPIO1_CTRL_ADD)) |= (1 << GPIO_ACIN_PIN);
    //H330
    #if 0
     tmpReg = *((volatile u32 *)(GPIO1_MODE_ADDR));  //SPIS_MODE=01.#GPIO14-17
    *((volatile u32 *)(GPIO1_MODE_ADDR)) = (tmpReg & (~(0x3<<2))) | (0x1<<2);
    
    *((volatile u32 *)(GPIO0_CTRL_ADD)) |= (1 << GPIO_G3_WAKEUP);
    *((volatile u32 *)(GPIO0_CTRL_ADD)) |= (1 << GPIO_G3_RESET);
    *((volatile u32 *)(GPIO0_CTRL_ADD)) |= (1 << GPIO_G3_POWEROFF);
    *((volatile u32 *)(GPIO0_CTRL_ADD)) |= (1 << GPIO_G3_POWERON);
    
    *((volatile u32 *)(GPIO0_DATA_ADD)) &= ~(1 << GPIO_G3_WAKEUP);
    *((volatile u32 *)(GPIO0_DATA_ADD)) |= (1 << GPIO_G3_RESET);
    *((volatile u32 *)(GPIO0_DATA_ADD)) |= (1 << GPIO_G3_POWEROFF);
    *((volatile u32 *)(GPIO0_DATA_ADD)) &= ~(1 << GPIO_G3_POWERON);
    #endif

    
    
    if(VIFI_BOARD_TYPE != BOARD_TYPE_V2_1)
    {
        lcdGpioInit();    //init the iic ports.
        lcdInit();         //option the lcd.
        //lcdDispString(0, 2, &lcdParam, "     Boot...    ");
        lcdFillDataFull(lcdParam.dataBuff);
    }
    printf(UBOOT_INFO);
    if(VIFI_BOARD_TYPE == BOARD_TYPE_V2_1)
    {
        return 0;
    }

    //detect power key
    while(pwrKeyDetCnt--)
    {
        if(GPIO_PWRKEY_GET() == 0)
        {
            pwrKeyKeep++;
            if(pwrKeyKeep > 10)
                pwrKeyStatus = 2;
        }
        mdelay(1);
    }
    #if 0
    Serial0_Init();
    printf("\nSampling the battery voltage,waiting...\n");
    Serial0_RecvHdl();  //get at command ready

    Serial0_Send("ATE0\r\n");   //close echo
    Serial0_RecvHdl();
    Serial0_RecvHdl();
    Serial0_Send("AT+CBC\r\n");
    Serial0_RecvHdl();
    #endif

    while(1)
    {
        #if 0
        //H330 
        if(batStatusDet == 0)
        {
            if((batReadLoopCnt%50) == 0)
            {
                if(batReadLoopCnt >= 500)   //can't get the battery voltage.
                {
                    strcpy(strBuff, "< lost battery >");
                    lcdDispString(0, 2, &lcdParam, strBuff);
                    lcdFillDataFull(lcdParam.dataBuff);
                    mdelay(5000);
                    *((volatile u32 *)(GPIO0_DATA_ADD)) &= ~(1 << GPIO_PWREN_PIN);  //shut down.
                }
                else
                {
                    Serial0_Send("AT+CBC\r\n");
                    Serial0_RecvHdl();
                }
            }
            batReadLoopCnt++;
        }
        else
        {
            *((volatile u32 *)(GPIO0_DATA_ADD)) |= (1 << GPIO_G3_POWERON);
            *((volatile u32 *)(GPIO0_DATA_ADD)) &= ~(1 << GPIO_G3_POWEROFF);
        }
        #else
        //detect battery voltage.
        if(batStatusDet == 0)
        {
            if(GPIO_VOLDET_GET() == 0)   //
            {
                batStatusKeep++;
                if(batStatusKeep > 1)
                {
                    batStatusKeep = 0;
                    batStatusDet = 1;
                }
            }
            else
            {
                batStatusKeep = 0;
                batStatusDet = 2;
            }
        }
        else if(batStatusDet == 1)
        {
            if(GPIO_VOLDET_GET() == 1)   //
            {
                batStatusKeep++;
                if(batStatusKeep > 1)
                {
                    batStatusKeep = 0;
                    batStatusDet = 2;
                }
            }
            else
            {
                batStatusKeep = 0;
            }
        }
        #endif
        
        //detect ac adapter.
        if(adapterDet == 0)
        {
            if(GPIO_ACIN_GET() == 0)   //adapter in
            {
                adapterDetKeep++;
                if(adapterDetKeep > 1)
                {
                    adapterDetKeep = 0;
                    adapterDet = 1;
                }
            }
            else
            {
                adapterDetKeep = 0;
            }
        }
        else if(adapterDet == 1)
        {
            if(GPIO_ACIN_GET() == 1)   //no adapter
            {
                adapterDetKeep++;
                if(adapterDetKeep > 1)
                {
                    adapterDetKeep = 0;
                    adapterDet = 0;
                }
            }
            else
            {
                adapterDetKeep = 0;
            }
        }

        mdelay(10);
        if(statusDetWait++ < 5)
        {
            continue;
        }

        if(adapterDet == 1) //is charging
        {
            if(0)//(batStatusDet == 1) //low power
            {            
                if(dispDelay <= 1)
                {
                    strcpy(strBuff, " < Low power >  ");
                    lcdDispString(0, 2, &lcdParam, strBuff);
                    strcpy(strBuff, "  Charging      ");
                    lcdDispString(0, 4, &lcdParam, strBuff);
                    lcdFillDataFull(lcdParam.dataBuff);
                }
                else if(dispDelay == 100)
                {
                    strcpy(strBuff, " < Low power >  ");
                    lcdDispString(0, 2, &lcdParam, strBuff);
                    strcpy(strBuff, "  Charging.     ");
                    lcdDispString(0, 4, &lcdParam, strBuff);
                    lcdFillDataFull(lcdParam.dataBuff);
                }
                else if(dispDelay == 200)
                {
                    strcpy(strBuff, " < Low power >  ");
                    lcdDispString(0, 2, &lcdParam, strBuff);
                    strcpy(strBuff, "  Charging..    ");
                    lcdDispString(0, 4, &lcdParam, strBuff);
                    lcdFillDataFull(lcdParam.dataBuff);
                }
                else if(dispDelay == 300)
                {
                    strcpy(strBuff, " < Low power >  ");
                    lcdDispString(0, 2, &lcdParam, strBuff);
                    strcpy(strBuff, "  Charging...   ");
                    lcdDispString(0, 4, &lcdParam, strBuff);
                    lcdFillDataFull(lcdParam.dataBuff);
                }
                else if(dispDelay >= 400)
                {
                    dispDelay = 0;
                }
                dispDelay ++;
            }
            else//if(batStatusDet == 2)
            {
                strcpy(strBuff, "  < Power OK >  ");
                lcdDispString(0, 2, &lcdParam, strBuff);
                strcpy(strBuff, "    Start...    ");
                lcdDispString(0, 4, &lcdParam, strBuff);
            	lcdFillDataFull(lcdParam.dataBuff);
                break;
            }
        }
        else if(adapterDet == 0)    //no adapter
        {
	    	batStatusDet = 2;
            if(batStatusDet == 1)    //low power,shut down
            {
                strcpy(strBuff, " < Low power >  ");
                lcdDispString(0, 2, &lcdParam, strBuff);
                strcpy(strBuff, " Please charge! ");
                lcdDispString(0, 4, &lcdParam, strBuff);
                lcdFillDataFull(lcdParam.dataBuff);
                mdelay(5000);
                *((volatile u32 *)(GPIO0_DATA_ADD)) &= ~(1 << GPIO_PWREN_PIN);  //shut down.
            }
            else if(batStatusDet == 2)
            {
                if((pwrKeyStatus == 2) || (isSoftRst == 1))
                {
                    strcpy(strBuff, "  < Power OK >  ");
                    lcdDispString(0, 2, &lcdParam, strBuff);
                    strcpy(strBuff, "    Start...    ");
                    lcdDispString(0, 4, &lcdParam, strBuff);
                	lcdFillDataFull(lcdParam.dataBuff);
                    break;
                }
                else if(pwrKeyStatus == 0)  //no press.
                {
                    *((volatile u32 *)(GPIO0_DATA_ADD)) &= ~(1 << GPIO_PWREN_PIN);  //shut down.
                }
            }
        }
    }
    
	return EOS_OK;
}
